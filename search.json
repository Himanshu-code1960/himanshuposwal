[
  {
    "objectID": "posts/projects/use_cases.html",
    "href": "posts/projects/use_cases.html",
    "title": "Use Cases",
    "section": "",
    "text": "In this example, we denoise a noisy version of a picture using the total variation, bilateral, and wavelet denoising filters.\nTotal variation and bilateral algorithms typically produce “posterized” images with flat domains separated by sharp edges. It is possible to change the degree of posterization by controlling the tradeoff between denoising and faithfulness to the original image.\nimport matplotlib.pyplot as plt\n\nfrom skimage.restoration import (\n    denoise_tv_chambolle,\n    denoise_bilateral,\n    denoise_wavelet,\n    estimate_sigma,\n)\nfrom skimage import data, img_as_float\nfrom skimage.util import random_noise\n\n\noriginal = img_as_float(data.chelsea()[100:250, 50:300])\n\nsigma = 0.155\nnoisy = random_noise(original, var=sigma**2)\n\nfig, ax = plt.subplots(nrows=2, ncols=4, figsize=(8, 5), sharex=True, sharey=True)\n\nplt.gray()\n\n# Estimate the average noise standard deviation across color channels.\nsigma_est = estimate_sigma(noisy, channel_axis=-1, average_sigmas=True)\n# Due to clipping in random_noise, the estimate will be a bit smaller than the\n# specified sigma.\nprint(f'Estimated Gaussian noise standard deviation = {sigma_est}')\n\nax[0, 0].imshow(noisy)\nax[0, 0].axis('off')\nax[0, 0].set_title('Noisy')\nax[0, 1].imshow(denoise_tv_chambolle(noisy, weight=0.1, channel_axis=-1))\nax[0, 1].axis('off')\nax[0, 1].set_title('TV')\nax[0, 2].imshow(\n    denoise_bilateral(noisy, sigma_color=0.05, sigma_spatial=15, channel_axis=-1)\n)\nax[0, 2].axis('off')\nax[0, 2].set_title('Bilateral')\nax[0, 3].imshow(denoise_wavelet(noisy, channel_axis=-1, rescale_sigma=True))\nax[0, 3].axis('off')\nax[0, 3].set_title('Wavelet denoising')\n\nax[1, 1].imshow(denoise_tv_chambolle(noisy, weight=0.2, channel_axis=-1))\nax[1, 1].axis('off')\nax[1, 1].set_title('(more) TV')\nax[1, 2].imshow(\n    denoise_bilateral(noisy, sigma_color=0.1, sigma_spatial=15, channel_axis=-1)\n)\nax[1, 2].axis('off')\nax[1, 2].set_title('(more) Bilateral')\nax[1, 3].imshow(\n    denoise_wavelet(noisy, channel_axis=-1, convert2ycbcr=True, rescale_sigma=True)\n)\nax[1, 3].axis('off')\nax[1, 3].set_title('Wavelet denoising\\nin YCbCr colorspace')\nax[1, 0].imshow(original)\nax[1, 0].axis('off')\nax[1, 0].set_title('Original')\n\nfig.tight_layout()\n\nplt.show()\n\n\n\nOutput\n\n\n\n\n\nFace recognition is widely used in security, user authentication, and emotion detection. This computer vision example shows how to detect faces on an image using object detection framework based on machine learning.\nfrom skimage import data\nfrom skimage.feature import Cascade\n\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\n\n# Load the trained file from the module root.\ntrained_file = data.lbp_frontal_face_cascade_filename()\n\n# Initialize the detector cascade.\ndetector = Cascade(trained_file)\n\nimg = data.astronaut()\n\ndetected = detector.detect_multi_scale(\n    img=img, scale_factor=1.2, step_ratio=1, min_size=(60, 60), max_size=(123, 123)\n)\n\nfig, ax = plt.subplots()\nax.imshow(img, cmap='gray')\n\nfor patch in detected:\n    ax.axes.add_patch(\n        patches.Rectangle(\n            (patch['c'], patch['r']),\n            patch['width'],\n            patch['height'],\n            fill=False,\n            color='r',\n            linewidth=2,\n        )\n    )\n\nplt.show()\n\n\n\nOutput\n\n\n\n\n\nRendering text onto an image is a common technique used in various real-world applications.\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom skimage import data\n\nimg = data.cat()\n\nfig = plt.figure()\nfig.figimage(img, resize=True)\nfig.text(0, 0.99, \"I am stefan's cat.\", fontsize=32, va=\"top\")\nfig.canvas.draw()\nannotated_img = np.asarray(fig.canvas.renderer.buffer_rgba())\nplt.close(fig)\nfig, ax = plt.subplots()\nax.imshow(annotated_img)\nax.set_axis_off()\nax.set_position([0, 0, 1, 1])\nplt.show()\n\n\n\nOutput\n\n\n\n\n\nExample: Interact with 3D images (of kidney tissue)\n\nLoad image\n\nThis biomedical image is available through scikit-image’s data registry.\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport plotly\nimport plotly.express as px\nfrom skimage import data\ndata = data.kidney()\n\nn_plane, n_row, n_col, n_chan = data.shape\nLet us consider only a slice (2D plane) of the data for now. More specifically, let us consider the slice located halfway in the stack. The imshow function can display both grayscale and RGB(A) 2D images.\n_, ax = plt.subplots()\n_, ax = plt.subplots()\nax.imshow(data[n_plane // 2])\n\n\n\nOutput\n\n\nWe turn to Plotly’s implementation of the plotly.express.imshow() function, for it supports value ranges beyond (0.0, 1.0) for floats and (0, 255) for integers.\nvmin, vmax = data.min(), data.max()\nfig = px.imshow(data[n_plane // 2], zmax=vmax)\nplotly.io.show(fig)\n\n\n\nOutput"
  },
  {
    "objectID": "posts/projects/use_cases.html#denoising-a-picture",
    "href": "posts/projects/use_cases.html#denoising-a-picture",
    "title": "Use Cases",
    "section": "",
    "text": "In this example, we denoise a noisy version of a picture using the total variation, bilateral, and wavelet denoising filters.\nTotal variation and bilateral algorithms typically produce “posterized” images with flat domains separated by sharp edges. It is possible to change the degree of posterization by controlling the tradeoff between denoising and faithfulness to the original image.\nimport matplotlib.pyplot as plt\n\nfrom skimage.restoration import (\n    denoise_tv_chambolle,\n    denoise_bilateral,\n    denoise_wavelet,\n    estimate_sigma,\n)\nfrom skimage import data, img_as_float\nfrom skimage.util import random_noise\n\n\noriginal = img_as_float(data.chelsea()[100:250, 50:300])\n\nsigma = 0.155\nnoisy = random_noise(original, var=sigma**2)\n\nfig, ax = plt.subplots(nrows=2, ncols=4, figsize=(8, 5), sharex=True, sharey=True)\n\nplt.gray()\n\n# Estimate the average noise standard deviation across color channels.\nsigma_est = estimate_sigma(noisy, channel_axis=-1, average_sigmas=True)\n# Due to clipping in random_noise, the estimate will be a bit smaller than the\n# specified sigma.\nprint(f'Estimated Gaussian noise standard deviation = {sigma_est}')\n\nax[0, 0].imshow(noisy)\nax[0, 0].axis('off')\nax[0, 0].set_title('Noisy')\nax[0, 1].imshow(denoise_tv_chambolle(noisy, weight=0.1, channel_axis=-1))\nax[0, 1].axis('off')\nax[0, 1].set_title('TV')\nax[0, 2].imshow(\n    denoise_bilateral(noisy, sigma_color=0.05, sigma_spatial=15, channel_axis=-1)\n)\nax[0, 2].axis('off')\nax[0, 2].set_title('Bilateral')\nax[0, 3].imshow(denoise_wavelet(noisy, channel_axis=-1, rescale_sigma=True))\nax[0, 3].axis('off')\nax[0, 3].set_title('Wavelet denoising')\n\nax[1, 1].imshow(denoise_tv_chambolle(noisy, weight=0.2, channel_axis=-1))\nax[1, 1].axis('off')\nax[1, 1].set_title('(more) TV')\nax[1, 2].imshow(\n    denoise_bilateral(noisy, sigma_color=0.1, sigma_spatial=15, channel_axis=-1)\n)\nax[1, 2].axis('off')\nax[1, 2].set_title('(more) Bilateral')\nax[1, 3].imshow(\n    denoise_wavelet(noisy, channel_axis=-1, convert2ycbcr=True, rescale_sigma=True)\n)\nax[1, 3].axis('off')\nax[1, 3].set_title('Wavelet denoising\\nin YCbCr colorspace')\nax[1, 0].imshow(original)\nax[1, 0].axis('off')\nax[1, 0].set_title('Original')\n\nfig.tight_layout()\n\nplt.show()\n\n\n\nOutput"
  },
  {
    "objectID": "posts/projects/use_cases.html#face-detection-using-a-cascade-classifier",
    "href": "posts/projects/use_cases.html#face-detection-using-a-cascade-classifier",
    "title": "Use Cases",
    "section": "",
    "text": "Face recognition is widely used in security, user authentication, and emotion detection. This computer vision example shows how to detect faces on an image using object detection framework based on machine learning.\nfrom skimage import data\nfrom skimage.feature import Cascade\n\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\n\n# Load the trained file from the module root.\ntrained_file = data.lbp_frontal_face_cascade_filename()\n\n# Initialize the detector cascade.\ndetector = Cascade(trained_file)\n\nimg = data.astronaut()\n\ndetected = detector.detect_multi_scale(\n    img=img, scale_factor=1.2, step_ratio=1, min_size=(60, 60), max_size=(123, 123)\n)\n\nfig, ax = plt.subplots()\nax.imshow(img, cmap='gray')\n\nfor patch in detected:\n    ax.axes.add_patch(\n        patches.Rectangle(\n            (patch['c'], patch['r']),\n            patch['width'],\n            patch['height'],\n            fill=False,\n            color='r',\n            linewidth=2,\n        )\n    )\n\nplt.show()\n\n\n\nOutput"
  },
  {
    "objectID": "posts/projects/use_cases.html#render-text-onto-an-image",
    "href": "posts/projects/use_cases.html#render-text-onto-an-image",
    "title": "Use Cases",
    "section": "",
    "text": "Rendering text onto an image is a common technique used in various real-world applications.\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom skimage import data\n\nimg = data.cat()\n\nfig = plt.figure()\nfig.figimage(img, resize=True)\nfig.text(0, 0.99, \"I am stefan's cat.\", fontsize=32, va=\"top\")\nfig.canvas.draw()\nannotated_img = np.asarray(fig.canvas.renderer.buffer_rgba())\nplt.close(fig)\nfig, ax = plt.subplots()\nax.imshow(annotated_img)\nax.set_axis_off()\nax.set_position([0, 0, 1, 1])\nplt.show()\n\n\n\nOutput"
  },
  {
    "objectID": "posts/projects/use_cases.html#medical-image-processing",
    "href": "posts/projects/use_cases.html#medical-image-processing",
    "title": "Use Cases",
    "section": "",
    "text": "Example: Interact with 3D images (of kidney tissue)\n\nLoad image\n\nThis biomedical image is available through scikit-image’s data registry.\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport plotly\nimport plotly.express as px\nfrom skimage import data\ndata = data.kidney()\n\nn_plane, n_row, n_col, n_chan = data.shape\nLet us consider only a slice (2D plane) of the data for now. More specifically, let us consider the slice located halfway in the stack. The imshow function can display both grayscale and RGB(A) 2D images.\n_, ax = plt.subplots()\n_, ax = plt.subplots()\nax.imshow(data[n_plane // 2])\n\n\n\nOutput\n\n\nWe turn to Plotly’s implementation of the plotly.express.imshow() function, for it supports value ranges beyond (0.0, 1.0) for floats and (0, 255) for integers.\nvmin, vmax = data.min(), data.max()\nfig = px.imshow(data[n_plane // 2], zmax=vmax)\nplotly.io.show(fig)\n\n\n\nOutput"
  },
  {
    "objectID": "posts/projects/references.html",
    "href": "posts/projects/references.html",
    "title": "References & Further Reading",
    "section": "",
    "text": "References & Further Reading:\nTo deepen your understanding of scikit-image and its applications, here are some official resources, tutorials, and research papers that will help you explore more advanced image processing techniques.\n\n1. Official Documentation & GitHub Repository\n\nScikit-Image Official Documentation – Comprehensive guide on scikit-image functions, examples, and API reference.  Official Doc \nScikit-Image GitHub Repository – Source code, latest updates, and community discussions.  GitHub Repo \n\n\n\n2. Tutorials & Learning Resources\n\nPython Image Processing with Scikit-Image – A beginner-friendly introduction.  Real python Tutorial\nScikit-Image Course on DataCamp – Interactive coding exercises for image processing.  Datacamp Tutorial"
  },
  {
    "objectID": "posts/projects/intro.html",
    "href": "posts/projects/intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Images play a crucial role in modern applications, from medical imaging to AI-driven object detection. Scikit-image is a Python library built on NumPy, designed for easy and efficient image processing. It provides a collection of algorithms for image manipulation, transformation, and analysis, making it a popular choice for researchers, data scientists, and developers working in the field of computer vision.\n\n\nThe primary goal of scikit-image is to offer a well-structured and efficient image processing library that integrates seamlessly with the SciPy ecosystem. Some of its core purposes include:\n\nEase of Use: Provides a user-friendly API with intuitive functions for image processing.\nComprehensive Functionality: Includes a variety of operations such as filtering, segmentation, morphology, and feature detection.\nPerformance Optimization: Built on NumPy arrays for efficient computation and optimized performance.\nIntegration with Machine Learning: Often used as a preprocessing step in ML pipelines to prepare image data for training models.\nOpen-Source & Actively Maintained: Community-driven with contributions from researchers and developers worldwide."
  },
  {
    "objectID": "posts/projects/intro.html#purpose-of-scikit-image",
    "href": "posts/projects/intro.html#purpose-of-scikit-image",
    "title": "Introduction",
    "section": "",
    "text": "The primary goal of scikit-image is to offer a well-structured and efficient image processing library that integrates seamlessly with the SciPy ecosystem. Some of its core purposes include:\n\nEase of Use: Provides a user-friendly API with intuitive functions for image processing.\nComprehensive Functionality: Includes a variety of operations such as filtering, segmentation, morphology, and feature detection.\nPerformance Optimization: Built on NumPy arrays for efficient computation and optimized performance.\nIntegration with Machine Learning: Often used as a preprocessing step in ML pipelines to prepare image data for training models.\nOpen-Source & Actively Maintained: Community-driven with contributions from researchers and developers worldwide."
  },
  {
    "objectID": "posts/projects/conclusion.html",
    "href": "posts/projects/conclusion.html",
    "title": "Conclusion",
    "section": "",
    "text": "Image processing is a fundamental component of modern technology, playing a crucial role in fields ranging from medical diagnostics and autonomous vehicles to satellite imagery and security systems. scikit-image has emerged as a versatile, open-source Python library that makes high-quality image processing accessible to researchers, engineers, and developers.\nThrough its user-friendly API and efficient algorithms, scikit-image simplifies complex operations like edge detection, segmentation, feature extraction, and image transformations, making it an essential tool in scientific computing, AI, and machine learning applications.\n\n\n\nThe practical applications of scikit-image are vast and transformative. Let’s highlight some of the most impactful real-world use cases covered:\n\nMedical Imaging\n\n\nHelps radiologists detect fractures, tumors, and abnormalities in X-rays, MRIs, and CT scans.\nAssists in automated segmentation of medical images, improving diagnosis accuracy.\n\n\nRemote Sensing & Satellite Analysis\n\n\nEnables vegetation monitoring using NDVI, helping farmers optimize crop health.\nAids in flood damage assessment and land-use classification for environmental research.\n\n\nSecurity & Surveillance\n\n\nUsed in facial recognition and biometric authentication for access control.\nEnhances motion detection and anomaly detection in surveillance footage.\n\n\nManufacturing & Quality Control\n\n\nAutomates defect detection in industrial production, reducing human error.\nEnsures higher-quality consumer products by identifying scratches, cracks, and misalignments.\n\n\nTraffic & Object Detection\n\n\nCounts vehicles on roads to optimize traffic flow in smart city infrastructure.\nIdentifies pedestrians and objects for autonomous vehicle navigation.\n\nEach of these applications leverages the power of image processing to solve complex, real-world problems that impact industries and society.\n\n\n\nThere are many image processing libraries available, such as OpenCV and PIL, but scikit-image stands out due to its:\n\nEase of Use\n\n\nSimple, intuitive API for both beginners and experts.\nWorks seamlessly with NumPy arrays, making it ideal for scientific computing.\n\n\nPerformance & Efficiency\n\n\nUses optimized Cython and NumPy operations, making it fast and efficient.\nSupports multi-dimensional image processing (2D, 3D).\n\n\nRich Functionality\n\n\nOver 100 functions for filtering, segmentation, edge detection, and feature extraction.\nStrong support for color, grayscale, and multi-spectral image processing.\n\n\nWell-Documented & Actively Maintained\n\n\nProvides extensive documentation and active community support.\nPart of the SciPy ecosystem, ensuring compatibility with other scientific libraries.\n\n\n\n\nWith the rise of Artificial Intelligence (AI) and Machine Learning (ML), scikit-image is becoming even more valuable. Many AI applications rely on high-quality preprocessed images for deep learning models. Some future trends include:\n\nDeep Learning & Image Processing\n\n\nscikit-image can preprocess images for TensorFlow and PyTorch models in AI applications.\nUsed in automated medical diagnosis and computer vision projects.\n\n\nSmart Cities & IoT\n\n\nEnhances real-time surveillance and traffic monitoring using cameras and sensors.\nHelps in environmental monitoring, such as pollution detection via satellite imagery.\n\n\nIndustry 4.0 & Automation\n\n\nSupports robotics and automated quality control in industrial production.\nPlays a role in predictive maintenance by analyzing wear and tear in machines.\n\nAs technology advances, scikit-image will continue to be a cornerstone of image analysis across multiple fields.\n\n\n\nIf you’re working with computer vision, AI, or scientific image analysis, scikit-image is an essential library. Its combination of ease of use, powerful algorithms, and real-world applicability makes it a go-to tool for researchers, engineers, and developers.\n\nWho Should Use scikit-image?\n\n\nStudents & Researchers – Ideal for academic projects, simulations, and scientific analysis.\nAI/ML Practitioners – Great for preprocessing images for machine learning models.\nEngineers & Developers – Perfect for industrial automation and smart applications.\n\nWhether you’re analyzing medical scans, processing satellite images, or building AI models, scikit-image is a powerful tool to explore, experiment with, and apply in real-world scenarios."
  },
  {
    "objectID": "posts/projects/conclusion.html#the-power-of-scikit-image-in-image-processing",
    "href": "posts/projects/conclusion.html#the-power-of-scikit-image-in-image-processing",
    "title": "Conclusion",
    "section": "",
    "text": "Image processing is a fundamental component of modern technology, playing a crucial role in fields ranging from medical diagnostics and autonomous vehicles to satellite imagery and security systems. scikit-image has emerged as a versatile, open-source Python library that makes high-quality image processing accessible to researchers, engineers, and developers.\nThrough its user-friendly API and efficient algorithms, scikit-image simplifies complex operations like edge detection, segmentation, feature extraction, and image transformations, making it an essential tool in scientific computing, AI, and machine learning applications."
  },
  {
    "objectID": "posts/projects/conclusion.html#real-world-impact-of-scikit-image",
    "href": "posts/projects/conclusion.html#real-world-impact-of-scikit-image",
    "title": "Conclusion",
    "section": "",
    "text": "The practical applications of scikit-image are vast and transformative. Let’s highlight some of the most impactful real-world use cases covered:\n\nMedical Imaging\n\n\nHelps radiologists detect fractures, tumors, and abnormalities in X-rays, MRIs, and CT scans.\nAssists in automated segmentation of medical images, improving diagnosis accuracy.\n\n\nRemote Sensing & Satellite Analysis\n\n\nEnables vegetation monitoring using NDVI, helping farmers optimize crop health.\nAids in flood damage assessment and land-use classification for environmental research.\n\n\nSecurity & Surveillance\n\n\nUsed in facial recognition and biometric authentication for access control.\nEnhances motion detection and anomaly detection in surveillance footage.\n\n\nManufacturing & Quality Control\n\n\nAutomates defect detection in industrial production, reducing human error.\nEnsures higher-quality consumer products by identifying scratches, cracks, and misalignments.\n\n\nTraffic & Object Detection\n\n\nCounts vehicles on roads to optimize traffic flow in smart city infrastructure.\nIdentifies pedestrians and objects for autonomous vehicle navigation.\n\nEach of these applications leverages the power of image processing to solve complex, real-world problems that impact industries and society."
  },
  {
    "objectID": "posts/projects/conclusion.html#why-choose-scikit-image",
    "href": "posts/projects/conclusion.html#why-choose-scikit-image",
    "title": "Conclusion",
    "section": "",
    "text": "There are many image processing libraries available, such as OpenCV and PIL, but scikit-image stands out due to its:\n\nEase of Use\n\n\nSimple, intuitive API for both beginners and experts.\nWorks seamlessly with NumPy arrays, making it ideal for scientific computing.\n\n\nPerformance & Efficiency\n\n\nUses optimized Cython and NumPy operations, making it fast and efficient.\nSupports multi-dimensional image processing (2D, 3D).\n\n\nRich Functionality\n\n\nOver 100 functions for filtering, segmentation, edge detection, and feature extraction.\nStrong support for color, grayscale, and multi-spectral image processing.\n\n\nWell-Documented & Actively Maintained\n\n\nProvides extensive documentation and active community support.\nPart of the SciPy ecosystem, ensuring compatibility with other scientific libraries."
  },
  {
    "objectID": "posts/projects/conclusion.html#future-scope-integration-with-aiml",
    "href": "posts/projects/conclusion.html#future-scope-integration-with-aiml",
    "title": "Conclusion",
    "section": "",
    "text": "With the rise of Artificial Intelligence (AI) and Machine Learning (ML), scikit-image is becoming even more valuable. Many AI applications rely on high-quality preprocessed images for deep learning models. Some future trends include:\n\nDeep Learning & Image Processing\n\n\nscikit-image can preprocess images for TensorFlow and PyTorch models in AI applications.\nUsed in automated medical diagnosis and computer vision projects.\n\n\nSmart Cities & IoT\n\n\nEnhances real-time surveillance and traffic monitoring using cameras and sensors.\nHelps in environmental monitoring, such as pollution detection via satellite imagery.\n\n\nIndustry 4.0 & Automation\n\n\nSupports robotics and automated quality control in industrial production.\nPlays a role in predictive maintenance by analyzing wear and tear in machines.\n\nAs technology advances, scikit-image will continue to be a cornerstone of image analysis across multiple fields."
  },
  {
    "objectID": "posts/projects/conclusion.html#final-thoughts-a-must-have-tool-for-image-processing",
    "href": "posts/projects/conclusion.html#final-thoughts-a-must-have-tool-for-image-processing",
    "title": "Conclusion",
    "section": "",
    "text": "If you’re working with computer vision, AI, or scientific image analysis, scikit-image is an essential library. Its combination of ease of use, powerful algorithms, and real-world applicability makes it a go-to tool for researchers, engineers, and developers.\n\nWho Should Use scikit-image?\n\n\nStudents & Researchers – Ideal for academic projects, simulations, and scientific analysis.\nAI/ML Practitioners – Great for preprocessing images for machine learning models.\nEngineers & Developers – Perfect for industrial automation and smart applications.\n\nWhether you’re analyzing medical scans, processing satellite images, or building AI models, scikit-image is a powerful tool to explore, experiment with, and apply in real-world scenarios."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! I’m Himanshu Poswal, a B.Tech student at IIT Gandhinagar, specializing in Materials Science and Engineering. I’m deeply interested in technology and passionate about learning machine learning.\nI enjoy exploring how technology can solve real-world problems and am constantly looking for new ways to expand my knowledge. My goal is to build a strong foundation in AI and data science, applying these skills to meaningful projects.\nI’m always eager to learn, experiment, and collaborate—so feel free to connect!"
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\nIIT Gandhinagar | Gandhinagar, Gujarat B.Tech in Materials Science and Engineering | July 2024 - Present"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Himanshu Poswal",
    "section": "",
    "text": "Exposition Article (ES-114)\n\n\n\n\n\nThis project explores image processing using scikit-image.\n\n\n\n\n\nFeb 24, 2025\n\n\nHimanshu Poswal\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/projects/features.html",
    "href": "posts/projects/features.html",
    "title": "Key Features & Explanation",
    "section": "",
    "text": "Key Features & Explanation:\nscikit-image provides a comprehensive suite of image processing functions built on top of NumPy arrays, making it efficient and easy to integrate with scientific computing and machine learning workflows. Below are some of its most powerful functionalities:\n\n1. Image Loading & Display\nOne of the most fundamental tasks in image processing is loading an image from different sources (files, URLs, arrays) and displaying it properly. scikit-image provides io.imread() to read images, which works with various formats like PNG, JPEG, and TIFF.\nExample: Loading an Image from a URL and Displaying it:\nimport matplotlib.pyplot as plt\nfrom skimage import io\n\nimage = io.imread('https://upload.wikimedia.org/wikipedia/commons/8/89/Portrait_Placeholder.png')\n\nplt.imshow(image)\nplt.axis('off') \nplt.show()\nOutput: (Displays the loaded image)\n\nKey Functions: io.imread(), plt.imshow()\nUse Case: Reading and displaying images from different sources for further processing.\n\n\n\n2. Image Preprocessing & Filtering\nBefore performing complex operations, it’s essential to preprocess images. This can include blurring, sharpening, or noise reduction to improve image quality.\nExample: Applying a Gaussian Blur for Noise Reduction\nfrom skimage.filters import gaussian\n\nblurred_image = gaussian(image, sigma=2, multichannel=True)\n\nplt.imshow(blurred_image)\nplt.axis('off')\nplt.show()\nOutput: (Original vs. Blurred Image - noise is reduced)\n\nKey Functions: gaussian()\nUse Case: Reducing noise before edge detection, smoothing images for better segmentation.\n\n\n\n3. Edge Detection\nEdge detection helps in extracting object boundaries from an image. The Canny Edge Detector is a powerful method that finds edges while reducing noise.\nExample: Detecting Edges Using the Canny Algorithm\nfrom skimage.color import rgb2gray\nfrom skimage.feature import canny\n\ngray_image = rgb2gray(image)\n\nedges = canny(gray_image, sigma=1)\n\nplt.imshow(edges, cmap='gray')\nplt.axis('off')\nplt.show()\nOutput: (Edges of objects highlighted, making them more visible)\n\nKey Functions: canny(), rgb2gray()\nUse Case: Object detection, feature extraction, and shape recognition.\n\n\n\n4. Image Transformation (Resizing, Rotating, Warping)\nSometimes, images need to be resized or transformed before applying machine learning models.\nExample: Resizing an Image\nfrom skimage.transform import resize\n\nresized_image = resize(image, (100, 100))\n\nplt.imshow(resized_image)\nplt.axis('off')\nplt.show()\nOutput: (Smaller version of the original image, maintaining aspect ratio)\n\nKey Functions: resize(), rotate(), warp()\nUse Case: Standardizing image sizes for ML models, reducing computational load.\n\n\n\n5. Image Segmentation (Object Isolation)\nSegmentation is used to separate objects within an image. The SLIC (Simple Linear Iterative Clustering) algorithm helps in superpixel segmentation, breaking the image into meaningful regions.\nExample: Superpixel Segmentation Using SLIC\nfrom skimage.segmentation import slic\nfrom skimage.color import label2rgb\n\nsegments = slic(image, n_segments=100, compactness=10)\n\nsegmented_image = label2rgb(segments, image, kind='avg')\n\nplt.imshow(segmented_image)\nplt.axis('off')\nplt.show()\nOutput: (Image divided into multiple colored superpixels)\n\nKey Functions: slic(), label2rgb()\nUse Case: Identifying separate objects within an image (e.g., medical imaging, object tracking).\n\n\n\n6. Feature Extraction (Corner and Blob Detection)\nFeature extraction identifies important key points in images, useful in facial recognition, motion tracking, and object detection.\nExample: Detecting Corners Using Harris Detector\nfrom skimage.feature import corner_harris, corner_peaks\n\ncorners = corner_peaks(corner_harris(gray_image), min_distance=5)\n\nplt.imshow(gray_image, cmap='gray')\nplt.scatter(corners[:, 1], corners[:, 0], color='red', s=10)\nplt.axis('off')\nplt.show()\nOutput: (Red dots highlight detected corners in the image)\n\nKey Functions: corner_harris(), corner_peaks()\nUse Case: Object tracking, motion analysis, and pattern re cognition.\n\n\n\n7. Morphological Operations (Dilation, Erosion, Skeletonization)\nMorphological operations help in enhancing or removing structures in an image. These are useful in text recognition and medical imaging.\nExample: Applying Dilation and Erosion\nfrom skimage.morphology import dilation, erosion, disk\n\nselem = disk(3)\n\ndilated_image = dilation(gray_image, selem)\neroded_image = erosion(gray_image, selem)\n\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\nax[0].imshow(dilated_image, cmap='gray')\nax[0].set_title(\"Dilated Image\")\nax[0].axis('off')\n\nax[1].imshow(eroded_image, cmap='gray')\nax[1].set_title(\"Eroded Image\")\nax[1].axis('off')\n\nplt.show()\nOutput: (Left: Dilated Image - structures are expanded, Right: Eroded Image - structures are shrunk)\n\nKey Functions: dilation(), erosion(), disk()\nUse Case: Noise removal, shape detection, and medical imaging analysis.\n\n\n\n8. Color Space Conversions (RGB to Grayscale, HSV, LAB)\nConverting between color spaces helps in color-based object detection and segmentation.\nExample: Convert RGB to HSV\nfrom skimage.color import rgb2hsv\n\nhsv_image = rgb2hsv(image)\n\nplt.imshow(hsv_image)\nplt.axis('off')\nplt.show()\nOutput: (HSV representation of the image, useful for detecting color-based features)\n\nKey Functions: rgb2gray(), rgb2hsv(), rgb2lab()\nUse Case: Color-based segmentation, object tracking, and image enhancement.\n\nThese examples showcase how scikit-image simplifies powerful image processing techniques."
  },
  {
    "objectID": "posts/projects/projects.html",
    "href": "posts/projects/projects.html",
    "title": "Exposition Article (ES-114)",
    "section": "",
    "text": "1. Interactive Image Processing with scikit-image\n\nIntroduction\nInstallation & Setup\nKey Features\nUse Cases\nConclusion\nReferences & Further Reading\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/projects/setup.html",
    "href": "posts/projects/setup.html",
    "title": "Installation & Setup",
    "section": "",
    "text": "Installation & Setup:\nTo get started with scikit-image, follow these steps:\n\n1. Install Python\nEnsure you have Python installed. You can download the latest version from Python’s official website and follow the installation instructions for your operating system.\nTo verify the installation, run:\npython --version\n\n\n2. Create a Virtual Environment (Optional but Recommended)\nUsing a virtual environment helps manage dependencies effectively.\nOn macOS/Linux:\npython -m venv scikit_env\nsource scikit_env/bin/activate\nOn Windows:\npython -m venv scikit_env\nscikit_env\\Scripts\\activate\n\n\n3. Install scikit-image\nUse pip to install scikit-image:\npip install scikit-image\nYou may also need to install dependencies like numpy, matplotlib, and scipy:\npip install numpy matplotlib scipy\n\n\n4. Verify Installation\nAfter installation, open a Python shell and run:\nimport skimage\nprint(skimage.__version__)\nIf no errors appear and a version number is printed, the installation was successful.\n\n\n5. Installing Jupyter Notebook (For Interactive Development)\nIf you want an interactive development environment, install Jupyter Notebook:\npip install notebook\nThen, launch it using:\njupyter notebook\n\n\n6. Running Your First scikit-image Program\nCreate a Python script or Jupyter Notebook and test loading an image:\nimport matplotlib.pyplot as plt\nfrom skimage import io\n\nimage = io.imread('https://upload.wikimedia.org/wikipedia/commons/8/89/Portrait_Placeholder.png')\nplt.imshow(image)\nplt.axis('off')\nplt.show()\nIf an image is displayed without errors, your setup is complete!"
  }
]